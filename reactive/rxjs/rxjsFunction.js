var rxjsFunction = function (node) {
    // The figure is used to refer to the visual representation of the
    // reactive function, it is stored as the view.
    this._controlNode = node;

    // The output stream that represents this node. This will normally
    // be the the Rx stream generated by executing the reactive function.
    this.output = null;
};

rxjsFunction.prototype.getFunction = function () {
    return this.reactiveFunction;
};

rxjsFunction.prototype.getFunctionCall = function () {
    return this.functionCall;
};

rxjsFunction.prototype.getNodeExecution = function () {
    return this.nodeExecution;
};

/**
 * Get the output of this reactive RxJS node. When specific
 * changes need to be made to create the stream, this should
 * be implemented in the getExecution function.
 * 
 * @returns The RxJS Observable representing the output stream
 * after going through this reactive function.
 */
rxjsFunction.prototype.getOutput = function () {
    if (this.output === null) {
        this.output = this.getExecution();
    }
    return this.output;
};

rxjsFunction.prototype.subscribe = function (subscriptionModel) {
    // In this implementation, the subscription is handled by
    // rxjsSubscription, so this is a null function internally.
};

rxjsFunction.prototype.removeSubscription = function (subscriptionModel) {
    // In this implementation, the remove of a subscription is handled by
    // rxjsSubscription, so this is a null function internally.
    //TODO something here?
};

rxjsFunction.prototype.addInput = function (subscriptionModel) {
    // In this implentation the addition of new input is handled by
    // the controlNode, so the only thing that we are sure that needs
    // to be done is the update of this node.
};

rxjsFunction.prototype.removeInput = function (subscriptionModel) {
};

rxjsFunction.prototype.updateNode = function () {
    // First refresh the output with the new reactive values.
    this.output = this.getExecution();
};